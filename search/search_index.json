{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bienvenido a Aprendia Docs","text":"<p>Esta documentaci\u00f3n centraliza todos los recursos de nuestros proyectos educativos.</p> <ul> <li>Aprende sobre nuestros proyectos principales.</li> <li>Consulta gu\u00edas t\u00e9cnicas para colaborar.</li> </ul>"},{"location":"#proyectos-destacados","title":"\ud83d\ude80 Proyectos destacados","text":"<ul> <li>Alfabetizaci\u00f3n Interactiva</li> </ul> <p>\u2728 Esta documentaci\u00f3n est\u00e1 en constante actualizaci\u00f3n. \u00a1Contribuye y ay\u00fadanos a mejorar!</p>"},{"location":"guias/arquitectura-backend/","title":"Gu\u00eda de Arquitectura Base para Microservicios","text":"<p>Este documento establece la arquitectura base y las convenciones para el desarrollo de microservicios en nuestro ecosistema. El objetivo es proporcionar una gu\u00eda limpia, pragm\u00e1tica y agn\u00f3stica al lenguaje que garantice coherencia, mantenibilidad y escalabilidad en todos nuestros servicios. Nos enfocamos en una arquitectura RESTful inicial, con una visi\u00f3n clara hacia la futura integraci\u00f3n de sistemas basados en eventos.</p> <p>Adoptamos principios clave de Domain-Driven Design (DDD) y Screaming Architecture, organizando el c\u00f3digo de manera intuitiva por funcionalidades (features) y capas.</p>"},{"location":"guias/arquitectura-backend/#1-principios-arquitectonicos-clave","title":"1. Principios Arquitect\u00f3nicos Clave","text":"<ul> <li>Clean Architecture &amp; DDD: La l\u00f3gica de negocio (dominio) es el coraz\u00f3n y es independiente de tecnolog\u00edas externas (frameworks, bases de datos, sistemas de mensajer\u00eda). El dominio \"grita\" sus capacidades.</li> <li>Screaming Architecture: La estructura del c\u00f3digo debe reflejar el dominio del negocio, no las tecnolog\u00edas o frameworks. Una mirada r\u00e1pida a la estructura de carpetas debe indicar qu\u00e9 hace el sistema.</li> <li>Separaci\u00f3n de Preocupaciones (SoC): Cada capa y componente tiene una \u00fanica responsabilidad bien definida.</li> <li>Independencia del Lenguaje: Las ideas y patrones aqu\u00ed descritos son aplicables en Java, TypeScript, Python y otros lenguajes orientados a objetos.</li> <li>M\u00ednimo Over-engineering: Buscamos soluciones directas y efectivas, evitando complejidades innecesarias que no aporten valor inmediato.</li> <li>Orientaci\u00f3n a la Testeabilidad: La separaci\u00f3n de capas facilita las pruebas unitarias y de integraci\u00f3n de cada componente de forma aislada.</li> </ul>"},{"location":"guias/arquitectura-backend/#2-estructura-general-del-microservicio","title":"2. Estructura General del Microservicio","text":"<p>Todo microservicio seguir\u00e1 una estructura de carpetas que refleje sus features (funcionalidades de negocio) y capas internas.</p> <pre><code>.\n\u251c\u2500\u2500 src/                            # Carpeta ra\u00edz del c\u00f3digo fuente\n\u2502   \u251c\u2500\u2500 app/                        # C\u00f3digo principal de la aplicaci\u00f3n (Java/TypeScript/Python)\n\u2502   \u2502   \u251c\u2500\u2500 &lt;nombre-servicio&gt;/      # Namespace o paquete ra\u00edz del microservicio\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 application/        # Orquestaci\u00f3n de dependencias (DI)\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 core/               # Componentes fundamentales y transversales\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 features/           # M\u00f3dulos de funcionalidad (Screaming Architecture por feature)\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 &lt;feature-name&gt;/ # Ej: users, products, orders\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 controllers/    # Entrada HTTP (REST)\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 services/       # Aplicaci\u00f3n de casos de uso (orquesta dominio y data)\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 domain/         # L\u00f3gica de negocio, entidades, CASOS DE USO, interfaces de repositorio\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 data/           # Implementaciones de repositorios, DTOs, adaptadores\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 transports/     # Futura migraci\u00f3n a eventos/colas\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 common/             # Componentes comunes entre features (si aplica)\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 utils/              # Funciones auxiliares/comunes\n\u2502   \u2502   \u2514\u2500\u2500 MainApplication.java    # Punto de entrada (o main.ts, main.py)\n\u2502   \u251c\u2500\u2500 resources/                  # Archivos de configuraci\u00f3n, plantillas, etc. (Java)\n\u2502   \u2502   \u2514\u2500\u2500 application.properties.example / .env.example\n\u2502   \u2514\u2500\u2500 test/                       # C\u00f3digo de pruebas\n\u251c\u2500\u2500 Dockerfile.dev                  # Dockerfile para entorno de desarrollo\n\u251c\u2500\u2500 Dockerfile.prod                 # Dockerfile para entorno de producci\u00f3n\n\u251c\u2500\u2500 README.md                       # Documentaci\u00f3n del servicio\n\u251c\u2500\u2500 swagger.yaml / openapi.yaml     # Documentaci\u00f3n Swagger/OpenAPI\n\u2514\u2500\u2500 pom.xml / package.json / requirements.txt # Dependencias y configuraci\u00f3n del proyecto\n</code></pre>"},{"location":"guias/arquitectura-backend/#3-descripcion-de-capas-minimas-necesarias","title":"3. Descripci\u00f3n de Capas M\u00ednimas Necesarias","text":""},{"location":"guias/arquitectura-backend/#31-capa-core","title":"3.1. Capa core","text":"<p>Componentes fundamentales y transversales, independientes de la l\u00f3gica de negocio. Es la base de la aplicaci\u00f3n.</p> <p>Prop\u00f3sito: Proporcionar infraestructura b\u00e1sica y gen\u00e9rica que otras capas necesitan.</p> <p>Contiene:</p> <ul> <li>Configuraciones Globales</li> <li>Middlewares/Interceptors</li> <li>Manejo de Excepciones</li> <li>Logging</li> </ul> <p>Dependencias: No debe depender de ninguna otra capa espec\u00edfica de negocio (features).</p>"},{"location":"guias/arquitectura-backend/#32-capa-utils","title":"3.2. Capa utils","text":"<p>Funciones auxiliares o comunes que no encajan en ninguna otra capa espec\u00edfica.</p> <p>Prop\u00f3sito: Contener utilidades gen\u00e9ricas y reutilizables.</p> <p>Contiene: Funciones de ayuda para fechas, cadenas, criptograf\u00eda, etc.</p> <p>Dependencias: Debe ser lo m\u00e1s independiente posible.</p>"},{"location":"guias/arquitectura-backend/#33-capa-application","title":"3.3. Capa application","text":"<p>Punto central para la inyecci\u00f3n de dependencias y la orquestaci\u00f3n inicial de los servicios.</p> <p>Prop\u00f3sito: Configurar y proporcionar las instancias concretas de los servicios y sus dependencias a la capa de entrada (controllers).</p> <p>Contiene: M\u00f3dulos de configuraci\u00f3n de inyecci\u00f3n de dependencias.</p> <p>Dependencias: Depende de las interfaces definidas en domain y de las implementaciones de los servicios.</p>"},{"location":"guias/arquitectura-backend/#34-capa-features","title":"3.4. Capa features/ <p>Cada feature es un m\u00f3dulo de negocio independiente, encapsulando una funcionalidad completa.</p>","text":""},{"location":"guias/arquitectura-backend/#341-controllers","title":"3.4.1. controllers","text":"<p>Punto de entrada de las solicitudes HTTP (REST).</p> <p>Prop\u00f3sito: Recibir solicitudes externas, delegar la ejecuci\u00f3n de casos de uso y formatear la respuesta.</p> <p>Dependencias: Depende de services y dtos. No debe contener l\u00f3gica de negocio directa.</p>"},{"location":"guias/arquitectura-backend/#342-services","title":"3.4.2. services","text":"<p>Aplicaci\u00f3n de casos de uso de negocio.</p> <p>Prop\u00f3sito: Orquestar el flujo de un caso de uso.</p> <p>Dependencias: Depende de domain y data.</p>"},{"location":"guias/arquitectura-backend/#343-domain","title":"3.4.3. domain","text":"<p>El coraz\u00f3n de la l\u00f3gica de negocio. Es completamente independiente de la tecnolog\u00eda.</p> <p>Prop\u00f3sito: Contener las reglas de negocio, entidades, objetos de valor y Casos de Uso puros, as\u00ed como las interfaces para interactuar con datos.</p> <p>Contiene:</p> <ul> <li>Entidades</li> <li>Objetos de Valor</li> <li>Casos de Uso</li> <li>Interfaces de Repositorio</li> <li>Excepciones de Dominio</li> </ul> <p>Dependencias: No debe depender de ninguna otra capa de la feature.</p>"},{"location":"guias/arquitectura-backend/#344-data","title":"3.4.4. data","text":"<p>Implementaciones de acceso a la base de datos y otros sistemas externos.</p> <p>Prop\u00f3sito: Implementar las interfaces de repositorio definidas en domain.</p> <p>Contiene:</p> <ul> <li>Implementaciones de Repositorios</li> <li>DTOs</li> <li>Adaptadores/Mapeadores</li> </ul> <p>Dependencias: Depende de domain y puede usar utilidades de core.</p>"},{"location":"guias/arquitectura-backend/#345-transports","title":"3.4.5. transports","text":"<p>Mecanismos de comunicaci\u00f3n futuros para eventos o colas.</p> <p>Prop\u00f3sito: Abstraer los detalles de la comunicaci\u00f3n as\u00edncrona.</p> <p>Dependencias: Deber\u00eda depender solo de domain y de core.</p>"},{"location":"guias/arquitectura-backend/#4-flujo-de-comunicacion-tipico-restful","title":"4. Flujo de Comunicaci\u00f3n T\u00edpico (RESTful)","text":"<ol> <li>Solicitud HTTP Externa: Llega al Controller.</li> <li>Controller: Valida el DTO de entrada. Si falla, responde con 400. Invoca el m\u00e9todo apropiado en Services.</li> <li>Service: Invoca el Caso de Uso de Domain. Maneja excepciones y transforma el resultado en un DTO de respuesta.</li> <li>Caso de Uso (Domain): Ejecuta la l\u00f3gica de negocio pura.</li> <li>Repository (Data): Traduce la solicitud a operaciones de bajo nivel y mapea la respuesta.</li> <li>Dominio: Aplica transformaciones o validaciones internas.</li> <li>Retorno de Datos: El resultado es devuelto al Caso de Uso, luego al Service, y finalmente al Controller.</li> <li>Controller: Env\u00eda el DTO de respuesta como respuesta HTTP.</li> </ol>"},{"location":"guias/arquitectura-backend/#5-componentes-obligatorios-del-microservicio","title":"5. Componentes Obligatorios del Microservicio","text":""},{"location":"guias/arquitectura-backend/#51-dockerfile-funcional","title":"5.1. Dockerfile Funcional <ul> <li>Dockerfile.dev: Optimizado para desarrollo.</li> <li>Dockerfile.prod: Optimizado para producci\u00f3n.</li> </ul>","text":""},{"location":"guias/arquitectura-backend/#52-archivo-de-configuracion-de-entorno","title":"5.2. Archivo de Configuraci\u00f3n de Entorno <ul> <li>.env.example (TypeScript/Python)</li> <li>application.properties.example (Java)</li> </ul>","text":""},{"location":"guias/arquitectura-backend/#53-documentacion-swaggeropenapi","title":"5.3. Documentaci\u00f3n Swagger/OpenAPI <ul> <li>Archivo <code>swagger.yaml</code> o <code>openapi.yaml</code>.</li> <li>Accesible v\u00eda <code>/docs</code> en desarrollo.</li> </ul>","text":""},{"location":"guias/arquitectura-backend/#54-readmemd-completo","title":"5.4. README.md Completo <ul> <li>Descripci\u00f3n del microservicio y su dominio.</li> <li>Prerrequisitos.</li> <li>Pasos para ejecutar el servicio.</li> <li>Comandos de pruebas.</li> <li>Instrucciones para documentaci\u00f3n Swagger/OpenAPI.</li> </ul>","text":""},{"location":"guias/arquitectura-backend/#55-punto-de-entrada-bien-definido","title":"5.5. Punto de Entrada Bien Definido <ul> <li>MainApplication.java (Java)</li> <li>main.ts (TypeScript)</li> <li>main.py (Python)</li> </ul>","text":""},{"location":"guias/arquitectura-backend/#56-control-centralizado-de-errores-y-status-http","title":"5.6. Control Centralizado de Errores y Status HTTP <ul> <li>Uso de interceptores, filtros o aspectos globales.</li> <li>Mapeo de excepciones a c\u00f3digos HTTP sem\u00e1nticos.</li> <li>Cuerpo de respuesta de error estandarizado.</li> <li>Logging adecuado de errores.</li> </ul>","text":""},{"location":"guias/arquitectura-backend/#57-sistema-de-logging-estructurado","title":"5.7. Sistema de Logging Estructurado <ul> <li>Preferir formatos JSON.</li> <li>Usar niveles apropiados (DEBUG, INFO, WARN, ERROR).</li> <li>Incluir contexto relevante.</li> </ul>","text":""},{"location":"guias/arquitectura-backend/#6-directrices-adicionales","title":"6. Directrices Adicionales","text":"<ul> <li>Inmutabilidad: Preferir la inmutabilidad para Entidades y DTOs.</li> <li>Validaci\u00f3n de Entrada: Validaci\u00f3n robusta de todos los DTOs de entrada.</li> <li>Nomenclatura Consistente: Seguir convenciones claras.</li> <li>Pruebas Unitarias e Integraci\u00f3n: Fomentar cobertura en todas las capas, especialmente en domain y services.</li> </ul>"},{"location":"guias/arquitectura-mobile/","title":"Gu\u00eda de Arquitectura para Frontend Mobile (Flutter)","text":"<p>Este documento es una gu\u00eda t\u00e9cnica esencial para desarrolladores que se unen o colaboran en nuestro proyecto frontend en Flutter. Detalla la arquitectura, las convenciones de c\u00f3digo y las buenas pr\u00e1cticas que seguimos para asegurar una integraci\u00f3n fluida y un desarrollo coherente, mantenible y escalable.</p> <p>Nuestra arquitectura se basa en una combinaci\u00f3n estricta de Clean Architecture y Domain-Driven Design (DDD), con una organizaci\u00f3n modular que sigue los principios de Screaming Architecture dentro de las funcionalidades (features).</p>"},{"location":"guias/arquitectura-mobile/#1-estructura-del-proyecto-y-capas","title":"1. Estructura del Proyecto y Capas","text":"<p>El proyecto est\u00e1 organizado en capas de alto nivel y, dentro de estas, en m\u00f3dulos de funcionalidad. Las dependencias siempre fluyen hacia el centro, manteniendo el desacoplamiento y cumpliendo con el Principio de Inversi\u00f3n de Dependencias (DIP) de SOLID.</p> <pre><code>.\n\u251c\u2500\u2500 lib\n\u2502   \u251c\u2500\u2500 core                    # Componentes fundamentales y transversales\n\u2502   \u251c\u2500\u2500 shared                  # Widgets y utilidades reutilizables\n\u2502   \u251c\u2500\u2500 features                # M\u00f3dulos de funcionalidad (Screaming Architecture por feature)\n\u2502   \u2502   \u251c\u2500\u2500 auth                # Ejemplo de Feature: Autenticaci\u00f3n\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 application     # Inyecci\u00f3n de dependencias para esta feature\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 domain          # L\u00f3gica de negocio, Casos de Uso, Entidades, Repositorios (Interfaces)\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 data            # Implementaciones de repositorios (fuentes de datos), DTOs, Adaptadores\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 presentation    # Vistas, Widgets y View Models\n\u2502   \u2502   \u2514\u2500\u2500 ... otros features\n\u2502   \u2514\u2500\u2500 main.dart               # Punto de entrada de la aplicaci\u00f3n\n\u251c\u2500\u2500 pubspec.yaml\n\u251c\u2500\u2500 analysis_options.yaml\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"guias/arquitectura-mobile/#11-capa-core-libcore","title":"1.1. Capa core (<code>/lib/core</code>)","text":"<p>Contiene componentes fundamentales y transversales, independientes de la l\u00f3gica de negocio y de la UI.</p> <ul> <li>Prop\u00f3sito: Proporcionar la infraestructura b\u00e1sica y gen\u00e9rica que otras capas necesitan.</li> <li> <p>Contiene:</p> <ul> <li><code>/config</code>: Configuraciones de entorno, constantes globales.</li> <li><code>/errors</code>: Clases base para <code>Failures</code> y excepciones a nivel de aplicaci\u00f3n (ej. <code>ServerFailure</code>, <code>NetworkFailure</code>).</li> <li><code>/network</code>: Configuraci\u00f3n global de Dio  (<code>dio_config.dart</code>), interceptores gen\u00e9ricos.</li> <li><code>/utils</code>: Utilidades gen\u00e9ricas (ej. <code>logger.dart</code>).</li> </ul> </li> <li> <p>Convenciones:</p> <ul> <li>No debe depender de ninguna otra capa de negocio (<code>features</code>, <code>shared</code>). Puede ser utilizada por cualquiera.</li> </ul> </li> </ul>"},{"location":"guias/arquitectura-mobile/#12-capa-shared-libshared","title":"1.2. Capa shared (<code>/lib/shared</code>)","text":"<p>Componentes reutilizables comunes a trav\u00e9s de m\u00faltiples <code>features</code>, m\u00e1s cercanos a la presentaci\u00f3n o utilidades de UI.</p> <ul> <li> <p>Prop\u00f3sito: Centralizar c\u00f3digo com\u00fan para evitar duplicaci\u00f3n y promover la reutilizaci\u00f3n de componentes UI.</p> </li> <li> <p>Contiene:</p> <ul> <li><code>/widgets</code>: Widgets personalizados reutilizables (ej. <code>CustomButton</code>, <code>LoadingIndicator</code>).</li> <li><code>/styles</code>: Definiciones de temas, colores, fuentes.</li> <li><code>/helpers</code>: Funciones de ayuda generales (ej. <code>ValidationHelper</code>).</li> <li><code>/constants</code>: Constantes relacionadas con la UI o valores compartidos.</li> </ul> </li> <li> <p>Convenciones:</p> <ul> <li>Puede depender de <code>core</code>. No debe depender de ninguna <code>feature</code>.</li> </ul> </li> </ul>"},{"location":"guias/arquitectura-mobile/#13-capa-features-libfeatures","title":"1.3. Capa features (<code>/lib/features</code>)","text":"<p>Esta es la capa principal donde reside la l\u00f3gica de negocio modularizada. Cada <code>feature</code> (ej. <code>/lib/features/auth</code>) es una funcionalidad independiente que sigue la Clean Architecture internamente.</p> <ul> <li> <p>Prop\u00f3sito: Encapsular funcionalidades completas del negocio, permitiendo un desarrollo, prueba y mantenimiento aislados.</p> </li> <li> <p>Contiene: Cada <code>feature</code> tiene sus propias subcarpetas:</p> <ul> <li> <p><code>/application</code>:</p> <ul> <li>Prop\u00f3sito: M\u00f3dulo de inyecci\u00f3n de dependencias y orquestaci\u00f3n de alto nivel para la <code>feature</code>. Proporciona las instancias concretas de casos de uso y sus dependencias a la capa de <code>presentation</code>.</li> <li>Contiene: Archivos de configuraci\u00f3n de inyecci\u00f3n (ej. <code>auth_injector.dart</code>).</li> </ul> </li> <li> <p><code>/domain</code>:</p> <ul> <li>Prop\u00f3sito: El coraz\u00f3n de la <code>feature</code>. Contiene la l\u00f3gica de negocio pura, incluyendo los Casos de Uso.</li> <li>Contiene: <code>/entities</code>, <code>/value_objects</code>, <code>/repositories</code> (Interfaces), <code>/use_cases</code>, <code>/exceptions</code> (de negocio).</li> <li>Convenciones: No debe depender de ninguna otra capa de la feature (data, presentation). Puede depender de core/errors.</li> </ul> </li> <li> <p><code>/data</code>:</p> <ul> <li>Prop\u00f3sito: Implementa los contratos (interfaces) del Dominio, manejando la entrada y salida de datos (APIs, bases de datos locales).</li> <li>Contiene: <code>/repositories</code> (Implementaciones concretas), <code>/data_sources</code> o <code>/api_clients</code> (usan Dio), <code>/dtos</code>, <code>/adapters</code> o <code>/mappers</code>.</li> <li>Convenciones: Solo debe depender de la capa <code>domain</code> de su <code>feature</code> y de la capa <code>core</code>.</li> </ul> </li> <li> <p><code>/presentation</code>:</p> <ul> <li>Prop\u00f3sito: Contiene la interfaz de usuario.</li> <li>Contiene: <code>/pages</code>, <code>/widgets</code> (espec\u00edficos de la feature), <code>/view_models</code> (<code>ChangeNotifier</code> de Provider).</li> <li>Convenciones: Solo debe depender de la capa <code>application</code> de su <code>feature</code> y de la capa <code>shared</code>.</li> </ul> </li> </ul> </li> <li> <p>Convenciones Generales de <code>features</code>:</p> <ul> <li>Cada <code>feature</code> es un m\u00f3dulo aut\u00f3nomo. Las dependencias internas siguen: <code>Presentation</code> -&gt; <code>Application</code> -&gt; <code>Domain</code> &lt;- <code>Data</code>.</li> <li>Puede depender de <code>core</code> y <code>shared</code>. No debe depender directamente de otras <code>features</code>.</li> </ul> </li> </ul>"},{"location":"guias/arquitectura-mobile/#2-flujo-de-comunicacion-y-gestion-de-dependencias","title":"2. Flujo de Comunicaci\u00f3n y Gesti\u00f3n de Dependencias","text":""},{"location":"guias/arquitectura-mobile/#21-flujo-de-datos-una-via","title":"2.1. Flujo de Datos (Una V\u00eda)","text":"<ol> <li>Vista (Feature/Presentation): Evento de UI.</li> <li>View Model (Feature/Presentation): Invoca el Caso de Uso de <code>feature/domain/use_cases</code>.</li> <li>Caso de Uso (Feature/Domain): Ejecuta l\u00f3gica de negocio, utiliza interfaces de Repositorio de <code>feature/domain/repositories</code>.</li> <li>Repositorio (Feature/Domain - Interfaz): Llama a un m\u00e9todo definido en la interfaz del <code>Repository</code>.</li> <li>Implementaci\u00f3n del Repositorio (Feature/Data): Realiza la operaci\u00f3n real (ej. llamada a API con Dio), maneja DTOs de <code>feature/data/dtos</code> y los mapea a las Entidades de Dominio.</li> <li>Dominio (Feature/Domain): Entidades aplican reglas de negocio puras.</li> <li>Retorno: El resultado se propaga al ViewModel.</li> <li>View Model: Actualiza su estado interno y notifica a sus oyentes (<code>notifyListeners()</code>).</li> <li>Vista: Se reconstruye para reflejar el nuevo estado.</li> </ol>"},{"location":"guias/arquitectura-mobile/#22-inyeccion-de-dependencias-capa-de-aplicacion","title":"2.2. inyecci\u00f3n de Dependencias (Capa de Aplicaci\u00f3n)","text":"<p>La capa de Aplicaci\u00f3n es clave para la Inversi\u00f3n de Dependencias (DIP), configurando y proporcionando las dependencias concretas.</p> <ul> <li>Configuraci\u00f3n centralizada en <code>main.dart</code> o <code>app_router.dart</code>:</li> </ul> <pre><code>MultiProvider(\n  providers: [\n    // Dependencias Core/Globales\n    Provider&lt;Dio&gt;(create: (_) =&gt; DioConfig.createDio()),\n\n    // Feature: Auth Dependencies (Data -&gt; Domain -&gt; Presentation)\n    Provider&lt;AuthApiClient&gt;(create: (context) =&gt; AuthApiClient(context.read&lt;Dio&gt;())),\n    Provider&lt;UserRepository&gt;(create: (context) =&gt; UserRepositoryImpl(context.read&lt;AuthApiClient&gt;())),\n    Provider&lt;SignInUserUseCase&gt;(create: (context) =&gt; SignInUserUseCase(context.read&lt;UserRepository&gt;())),\n    ChangeNotifierProvider&lt;AuthViewModel&gt;(create: (context) =&gt; AuthViewModel(context.read&lt;SignInUserUseCase&gt;())),\n  ],\n  child: MyApp(),\n);\n</code></pre> <ul> <li>Inyecci\u00f3n en Constructores: Todas las clases reciben sus dependencias a trav\u00e9s de sus constructores.</li> </ul> <pre><code>// Ejemplo: Caso de Uso recibiendo un Repositorio (Interfaz)\nclass SignInUserUseCase {\n  final UserRepository _userRepository;\n  SignInUserUseCase(this._userRepository);\n  // ...\n}\n</code></pre>"},{"location":"guias/arquitectura-mobile/#3-manejo-de-datos-dtos-y-adaptadores-en-la-capa-data","title":"3. Manejo de Datos: DTOs y Adaptadores en la Capa <code>data</code>","text":""},{"location":"guias/arquitectura-mobile/#31-data-transfer-objects-dtos","title":"3.1. Data Transfer Objects (DTOs)","text":"<p>Los DTOs son clases simples e inmutables, para transferir datos entre las capas. Se ubican en <code>/lib/features/[feature]/data/dtos.</code></p> <ul> <li>Implementaci\u00f3n: Se crear\u00e1n manualmente, incluyendo m\u00e9todos como <code>fromJson</code> y <code>toJson</code> para la serializaci\u00f3n/deserializaci\u00f3n, o m\u00e9todos de mapeo directo si la comunicaci\u00f3n no es JSON.</li> </ul> <pre><code>// Ejemplo: AuthRequestDto\nclass AuthRequestDto {\n  final String email;\n  final String password;\n  AuthRequestDto({required this.email, required this.password});\n  Map&lt;String, dynamic&gt; toJson() =&gt; {'email': email, 'password': password};\n}\n\n// Ejemplo: AuthResponseDto\nclass AuthResponseDto {\n  final String token;\n  final String userId;\n  AuthResponseDto({required this.token, required this.userId});\n  factory AuthResponseDto.fromJson(Map&lt;String, dynamic&gt; json) {\n    return AuthResponseDto(token: json['token'], userId: json['user_id']);\n  }\n}\n</code></pre>"},{"location":"guias/arquitectura-mobile/#32-adaptadores-mapeadores-en-la-capa-data","title":"3.2. Adaptadores (Mapeadores) en la capa <code>data</code>","text":"<p>Transforman datos entre DTOs y entidades de dominio.</p> <ul> <li> <p>Prop\u00f3sito: Mapear los DTOs de <code>data</code> (ej. <code>AuthResponseDto</code>) a las Entidades de Dominio (ej. <code>User</code>) y viceversa.</p> </li> <li> <p>Ubicaci\u00f3n: Como m\u00e9todos dentro de los DTOs, como extensiones, o en clases <code>Mapper</code> dedicadas en <code>/lib/features/[feature]/data/mappers</code>.</p> </li> </ul> <pre><code>// Ejemplo: M\u00e9todo de mapeo en AuthResponseDto\nclass AuthResponseDto {\n  // ... propiedades y fromJson\n  User toDomainEntity() {\n    return User(id: userId, token: token); // Mapeo a Entidad de Dominio\n  }\n}\n\n// Uso en la Implementaci\u00f3n del Repositorio:\nclass UserRepositoryImpl implements UserRepository {\n  // ...\n  Future&lt;User&gt; signIn(String email, String password) async {\n    final requestDto = AuthRequestDto(email: email, password: password);\n    final responseDto = await _authApiClient.signIn(requestDto);\n    return responseDto.toDomainEntity(); // Usa el m\u00e9todo de mapeo\n  }\n}\n</code></pre>"},{"location":"guias/arquitectura-mobile/#4-comunicacion-con-apis-dio","title":"4. Comunicaci\u00f3n con APIs: Dio","text":"<p>Dio es nuestro cliente HTTP principal, configurado globalmente en la capa <code>core</code> y utilizado por los <code>ApiClients</code> en la capa <code>data</code>.</p>"},{"location":"guias/arquitectura-mobile/#41-configuracion-global-de-dio","title":"4.1. Configuraci\u00f3n Global de Dio","text":"<ul> <li> <p>La instancia de Dio se crea y configura en <code>lib/core/network/dio_config.dart</code>.</p> </li> <li> <p>Incluye <code>BaseOptions</code>, <code>LogInterceptor</code>, y <code>InterceptorsWrapper</code> para l\u00f3gica transversal (autenticaci\u00f3n, manejo de errores HTTP gen\u00e9ricos).</p> </li> </ul> <pre><code>// lib/core/network/dio_config.dart\nclass DioConfig {\n  static Dio createDio() {\n    final dio = Dio(BaseOptions( /* ... */ ));\n    dio.interceptors.add(LogInterceptor( /* ... */ ));\n    dio.interceptors.add(InterceptorsWrapper(\n      onRequest: (options, handler) async { /* A\u00f1adir tokens */ return handler.next(options); },\n      onError: (e, handler) async { /* Manejo 401, etc. */ return handler.next(e); },\n    ));\n    return dio;\n  }\n}\n</code></pre>"},{"location":"guias/arquitectura-mobile/#42-clientes-de-api-en-la-capa-data","title":"4.2. Clientes de API (en la capa <code>data</code>)","text":"<ul> <li> <p>Clases dedicadas en <code>/lib/features/[feature]/data/data_sources</code> que exponen m\u00e9todos para cada endpoint de la API.</p> </li> <li> <p>Reciben la instancia de <code>Dio</code> global.</p> </li> <li> <p>Manejan la llamada HTTP y devuelven los DTOs de <code>data</code>.</p> </li> </ul> <pre><code>// lib/features/auth/data/data_sources/auth_api_client.dart\nclass AuthApiClient {\n  final Dio _dio;\n  AuthApiClient(this._dio);\n  Future&lt;AuthResponseDto&gt; signIn(AuthRequestDto requestDto) async {\n    try {\n      final response = await _dio.post('/auth/login', data: requestDto.toJson());\n      return AuthResponseDto.fromJson(response.data);\n    } on DioException {\n      rethrow; // Relanzar para que el Repositorio la capture\n    }\n  }\n}\n</code></pre>"},{"location":"guias/arquitectura-mobile/#5-manejo-de-errores","title":"5. Manejo de errores","text":"<p>Un manejo de errores consistente a trav\u00e9s de las capas es fundamental.</p>"},{"location":"guias/arquitectura-mobile/#51-clases-de-fallo-base-coreerrors","title":"5.1. Clases de Fallo Base (<code>core/errors</code>)","text":"<ul> <li>Define una jerarqu\u00eda de clases de <code>Failure</code> en <code>/lib/core/errors</code> para fallos t\u00e9cnicos o del sistema (ej. <code>ServerFailure</code>, <code>NetworkFailure</code>).</li> </ul> <pre><code>// lib/core/errors/failures.dart\nabstract class Failure { /* ... */ }\nclass ServerFailure extends Failure { /* ... */ }\nclass NetworkFailure extends Failure { /* ... */ }\n</code></pre>"},{"location":"guias/arquitectura-mobile/#52-excepciones-de-dominio-featuresfeaturedomainexceptions","title":"5.2. Excepciones de Dominio (<code>features/[feature]/domain/exceptions</code>)","text":"<ul> <li>Se definen por cada <code>feature</code> para representar errores de negocio puros (ej. <code>InvalidCredentialsException</code>, <code>UserNotFoundException</code>).</li> </ul> <pre><code>// lib/features/auth/domain/exceptions/auth_exceptions.dart\nabstract class AuthException implements Exception { /* ... */ }\nclass InvalidCredentialsException extends AuthException { /* ... */ }\n</code></pre>"},{"location":"guias/arquitectura-mobile/#53-mapeo-y-propagacion-de-errores","title":"5.3. Mapeo y Propagaci\u00f3n de Errores","text":"<p>El mapeo de errores es un proceso de dos pasos crucial:</p> <ul> <li> <p>Capa <code>data</code> (<code>features/[feature]/data/repositories</code>):</p> <ul> <li> <p>Captura <code>DioException</code> y otras excepciones de bajo nivel.</p> </li> <li> <p>Mapea estas excepciones a las Excepciones de Dominio o a los <code>Failure</code> gen\u00e9ricos de <code>core</code>.</p> </li> <li> <p>Luego, la excepci\u00f3n/fallo se relanza.</p> </li> </ul> </li> </ul> <pre><code>// Dentro de UserRepositoryImpl.signIn\n} on DioException catch (e) {\n  if (e.response?.statusCode == 400) throw InvalidCredentialsException('Credenciales inv\u00e1lidas.');\n  else if (e.type == DioExceptionType.connectionTimeout) throw NetworkFailure();\n  else throw ServerFailure(); // u otro Failure m\u00e1s gen\u00e9rico\n} catch (e) {\n  throw Failure(message: 'Error desconocido en datos: ${e.toString()}');\n}\n</code></pre> <ul> <li> <p>Capa <code>domain</code> (<code>features/[feature]/domain/use_cases</code>):</p> <ul> <li>Los casos de uso simplemente relanzan las excepciones de Dominio o los <code>Failures</code> que les llegan.</li> </ul> </li> </ul> <pre><code>// Dentro de SignInUserUseCase.execute\n} on AuthException {\n  rethrow;\n} on Failure {\n  rethrow;\n} catch (e) {\n  throw Failure(message: 'Error inesperado en caso de uso: ${e.toString()}');\n}\n</code></pre> <ul> <li> <p>Capa <code>presentation</code> (<code>features/[feature]/presentation/view_models</code>):</p> <ul> <li> <p>Los ViewModel capturan las excepciones de Dominio y Failures.</p> </li> <li> <p>Traducen estos fallos en mensajes amigables para el usuario (_errorMessage) y actualizan el estado de la UI.</p> </li> </ul> </li> </ul> <pre><code>// Dentro de AuthViewModel.signIn\n} on InvalidCredentialsException catch (e) { _errorMessage = e.message; }\non NetworkFailure catch (e) { _errorMessage = e.message; }\non ServerFailure catch (e) { _errorMessage = e.message; }\n// ... otros catches\nfinally { _isLoading = false; notifyListeners(); }\n</code></pre>"},{"location":"guias/arquitectura-mobile/#54-presentacion-de-errores-en-la-ui","title":"5.4. Presentaci\u00f3n de Errores en la UI","text":"<ul> <li> <p>La Vista observa el <code>_errorMessage</code> del ViewModel y lo muestra usando componentes de <code>shared/widgets</code> (ej. <code>ErrorDialog</code>, <code>SnackBar</code>).</p> </li> <li> <p>El ViewModel debe limpiar el error (<code>clearError()</code>) despu\u00e9s de mostrarlo.</p> </li> </ul>"},{"location":"guias/arquitectura-mobile/#6-convenciones-generales-de-codigo","title":"6. Convenciones generales de c\u00f3digo","text":"<ul> <li> <p>Nomenclatura:</p> <ul> <li> <p>Archivos y directorios: <code>snake_case</code>.</p> </li> <li> <p>Clases/Enums/Typedefs: <code>PascalCase</code>.</p> </li> <li> <p>M\u00e9todos/Variables: <code>camelCase</code>.</p> </li> <li> <p>Constantes: <code>SCREAMING_SNAKE_CASE</code> (globales est\u00e1ticas), <code>camelCase</code> con const.</p> </li> </ul> </li> <li> <p>Comentarios y Documentaci\u00f3n: Documentar clases, m\u00e9todos y propiedades p\u00fablicas con comentarios DART (<code>///.</code>)</p> </li> <li> <p>Inmutabilidad: Preferir objetos inmutables, especialmente en las capas de Dominio y en los DTOs. Considerar freezed para clases inmutables y copyWith.</p> </li> </ul>"},{"location":"proyectos/alfabetizacion/","title":"\ud83d\udcda Sistema de Alfabetizaci\u00f3n Interactiva","text":"<p>Este sistema est\u00e1 dise\u00f1ado para apoyar el proceso de alfabetizaci\u00f3n de estudiantes que a\u00fan no saben leer ni escribir. A trav\u00e9s de una aplicaci\u00f3n m\u00f3vil intuitiva, el estudiante interact\u00faa directamente con el sistema, mientras que el alfabetizador gu\u00eda el proceso educativo.</p>"},{"location":"proyectos/alfabetizacion/#objetivo","title":"\ud83c\udfaf Objetivo","text":"<p>Optimizar el proceso de ense\u00f1anza-aprendizaje en alfabetizaci\u00f3n, mediante la personalizaci\u00f3n de ejercicios que refuercen las habilidades del estudiante, garantizando un avance progresivo y adaptativo.</p>"},{"location":"proyectos/alfabetizacion/#como-funciona","title":"\ud83d\udc68\u200d\ud83c\udfeb \u00bfC\u00f3mo Funciona?","text":""},{"location":"proyectos/alfabetizacion/#1-evaluacion-inicial","title":"1. Evaluaci\u00f3n Inicial","text":"<p>El maestro alfabetizador ayuda al registro del alumno.</p>"},{"location":"proyectos/alfabetizacion/#2-generacion-de-recomendaciones","title":"2. Generaci\u00f3n de Recomendaciones","text":"<p>A partir de los resultados, el sistema utiliza algoritmos gen\u00e9ticos para seleccionar ejercicios adecuados al nivel del alumno.</p>"},{"location":"proyectos/alfabetizacion/#3-retroalimentacion-continua","title":"3. Retroalimentaci\u00f3n Continua","text":"<p>Con cada ejercicio realizado, el sistema reeval\u00faa el desempe\u00f1o y reajusta autom\u00e1ticamente las futuras recomendaciones.</p>"},{"location":"proyectos/alfabetizacion/#4-ciclo-adaptativo","title":"4. Ciclo Adaptativo","text":"<p>Este proceso se repite de forma continua, permitiendo un aprendizaje guiado y eficiente.</p> <p></p>"},{"location":"proyectos/alfabetizacion/#requerimientos","title":"\ud83d\udccc Requerimientos","text":"<ul> <li>Figma </li> </ul>"},{"location":"proyectos/alfabetizacion/#interaccion-de-usuario-y-diseno","title":"\ud83d\udda5\ufe0f Interacci\u00f3n de usuario y dise\u00f1o","text":"<ul> <li> <p>Arquitectura cloud </p> </li> <li> <p>Arquitectura de la informaci\u00f3n </p> </li> </ul>"}]}